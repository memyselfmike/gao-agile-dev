"""
Tests for git-cliff changelog configuration (.cliff.toml).

This test suite validates:
- Configuration file exists and is valid TOML
- All required sections are present
- Commit parsers are correctly configured
- Breaking change detection is enabled
- Changelog generation works correctly
- Section grouping is properly configured
"""

import subprocess
import sys
import tempfile
from pathlib import Path

import pytest

# Use tomllib (Python 3.11+) or fallback to toml package
if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomli as tomllib
    except ImportError:
        import toml as tomllib


@pytest.fixture
def project_root() -> Path:
    """Return the project root directory."""
    return Path(__file__).parent.parent.parent


@pytest.fixture
def cliff_config_path(project_root: Path) -> Path:
    """Return the path to .cliff.toml configuration file."""
    return project_root / ".cliff.toml"


@pytest.fixture
def cliff_config(cliff_config_path: Path) -> dict:
    """Load and return the .cliff.toml configuration."""
    if sys.version_info >= (3, 11):
        with open(cliff_config_path, "rb") as f:
            return tomllib.load(f)
    else:
        with open(cliff_config_path, "r", encoding="utf-8") as f:
            return tomllib.load(f)


def test_cliff_config_exists(cliff_config_path: Path):
    """Test that .cliff.toml configuration file exists."""
    assert cliff_config_path.exists(), ".cliff.toml configuration file not found"
    assert cliff_config_path.is_file(), ".cliff.toml is not a file"


def test_cliff_config_valid_toml(cliff_config_path: Path):
    """Test that .cliff.toml is valid TOML syntax."""
    try:
        if sys.version_info >= (3, 11):
            with open(cliff_config_path, "rb") as f:
                tomllib.load(f)
        else:
            with open(cliff_config_path, "r", encoding="utf-8") as f:
                tomllib.load(f)
    except Exception as e:
        pytest.fail(f".cliff.toml is not valid TOML: {e}")


def test_cliff_config_has_required_sections(cliff_config: dict):
    """Test that .cliff.toml has all required sections."""
    required_sections = ["changelog", "git"]

    for section in required_sections:
        assert section in cliff_config, f"Missing required section: [{section}]"


def test_changelog_section_configuration(cliff_config: dict):
    """Test that [changelog] section is properly configured."""
    changelog = cliff_config["changelog"]

    # Check required fields
    assert "header" in changelog, "changelog.header is missing"
    assert "body" in changelog, "changelog.body is missing"
    assert "footer" in changelog, "changelog.footer is missing"

    # Validate header content
    assert "# Changelog" in changelog["header"], "Header should contain '# Changelog'"
    assert "Keep a Changelog" in changelog["header"], "Header should reference Keep a Changelog"
    assert "Semantic Versioning" in changelog["header"], "Header should reference Semantic Versioning"

    # Validate body template has required elements
    body = changelog["body"]
    assert "{% if version" in body, "Body template should check for version"
    assert "{% for group" in body, "Body template should iterate over groups"
    assert "{% if commit.breaking %}" in body, "Body template should check for breaking changes"
    assert "[**BREAKING**]" in body, "Body template should mark breaking changes"

    # Validate footer
    assert "generated by git-cliff" in changelog["footer"], "Footer should credit git-cliff"


def test_git_section_configuration(cliff_config: dict):
    """Test that [git] section is properly configured."""
    git = cliff_config["git"]

    # Check conventional commits enabled
    assert git.get("conventional_commits") is True, "conventional_commits should be enabled"

    # Check breaking change protection
    assert git.get("protect_breaking_commits") is True, "protect_breaking_commits should be enabled"

    # Check tag pattern
    assert "tag_pattern" in git, "tag_pattern is missing"
    assert git["tag_pattern"] == "v[0-9].*", "tag_pattern should match semantic versions"

    # Check commit parsers exist
    assert "commit_parsers" in git, "commit_parsers are missing"
    assert len(git["commit_parsers"]) > 0, "commit_parsers list is empty"


def test_commit_type_parsers(cliff_config: dict):
    """Test that all conventional commit types are properly configured."""
    git = cliff_config["git"]
    commit_parsers = git["commit_parsers"]

    # Required commit types
    required_types = {
        "feat": "Features",
        "fix": "Bug Fixes",
        "perf": "Performance",
    }

    for commit_type, expected_group in required_types.items():
        parser = next(
            (p for p in commit_parsers if p["message"].startswith(f"^{commit_type}")),
            None
        )
        assert parser is not None, f"Missing parser for commit type: {commit_type}"
        assert parser["group"] == expected_group, (
            f"Parser for {commit_type} should map to group '{expected_group}', "
            f"got '{parser['group']}'"
        )


def test_commit_parsers_have_required_fields(cliff_config: dict):
    """Test that all commit parsers have required fields."""
    git = cliff_config["git"]
    commit_parsers = git["commit_parsers"]

    for i, parser in enumerate(commit_parsers):
        # Each parser must have either 'message' or 'body'
        assert "message" in parser or "body" in parser, (
            f"Parser at index {i} missing 'message' or 'body' field"
        )

        # Each parser must have 'group' field (even if skipped)
        # Note: Some parsers may not have 'group' if they only have 'skip'
        if "skip" not in parser or not parser["skip"]:
            assert "group" in parser, f"Non-skipped parser at index {i} missing 'group' field"


def test_breaking_change_detection(cliff_config: dict):
    """Test that breaking change detection is properly configured."""
    git = cliff_config["git"]

    # Breaking changes should be protected from being filtered out
    assert git.get("protect_breaking_commits") is True, "Breaking commits should be protected"

    # Body template should check for breaking changes
    changelog = cliff_config["changelog"]
    body = changelog["body"]
    assert "{% if commit.breaking %}" in body, "Body template should check for breaking changes"
    assert "[**BREAKING**]" in body, "Body template should mark breaking changes prominently"


def test_github_remote_configuration(cliff_config: dict):
    """Test that GitHub remote is configured."""
    assert "remote" in cliff_config, "Missing [remote] section"
    assert "github" in cliff_config["remote"], "Missing [remote.github] section"

    github = cliff_config["remote"]["github"]
    assert "owner" in github, "Missing remote.github.owner"
    assert "repo" in github, "Missing remote.github.repo"
    assert github["owner"] == "memyselfmike", "Incorrect GitHub owner"
    assert github["repo"] == "gao-agile-dev", "Incorrect GitHub repo"


@pytest.mark.integration
def test_changelog_generation_command_exists():
    """Test that git-cliff command is available (if installed)."""
    try:
        result = subprocess.run(
            ["git-cliff", "--help"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        assert result.returncode == 0, "git-cliff command failed"
        assert "git-cliff" in result.stdout.lower() or "git-cliff" in result.stderr.lower()
    except FileNotFoundError:
        pytest.skip("git-cliff not installed - install with: pip install git-cliff")
    except subprocess.TimeoutExpired:
        pytest.fail("git-cliff command timed out")


@pytest.mark.integration
def test_generate_changelog_with_config(project_root: Path, cliff_config_path: Path, tmp_path: Path):
    """Test that git-cliff can generate changelog with our configuration."""
    try:
        # Generate changelog to temporary file
        output_file = tmp_path / "test_changelog.md"

        result = subprocess.run(
            [
                "git-cliff",
                "--config", str(cliff_config_path),
                "--tag", "v0.2.0",
                "--output", str(output_file),
            ],
            cwd=project_root,
            capture_output=True,
            text=True,
            timeout=30,
        )

        # Check command executed (may have warnings about GitHub token, that's OK)
        assert result.returncode == 0, f"git-cliff failed: {result.stderr}"

        # Check output file was created
        assert output_file.exists(), "Changelog file was not created"

        # Check content
        content = output_file.read_text(encoding="utf-8")
        assert "# Changelog" in content, "Changelog should have header"
        assert len(content) > 100, "Changelog seems too short"

    except FileNotFoundError:
        pytest.skip("git-cliff not installed - install with: pip install git-cliff")
    except subprocess.TimeoutExpired:
        pytest.fail("git-cliff command timed out")


@pytest.mark.integration
def test_changelog_includes_commit_types(project_root: Path, cliff_config_path: Path, tmp_path: Path):
    """Test that generated changelog includes different commit types in sections."""
    try:
        output_file = tmp_path / "test_changelog_types.md"

        result = subprocess.run(
            [
                "git-cliff",
                "--config", str(cliff_config_path),
                "--tag", "v0.2.0",
                "--output", str(output_file),
            ],
            cwd=project_root,
            capture_output=True,
            text=True,
            timeout=30,
        )

        assert result.returncode == 0, f"git-cliff failed: {result.stderr}"

        content = output_file.read_text(encoding="utf-8")

        # Check that at least some sections exist
        # Note: Not all sections may exist depending on commit history
        possible_sections = [
            "### Features",
            "### Bug Fixes",
            "### Documentation",
            "### Performance",
            "### Refactoring",
        ]

        sections_found = [section for section in possible_sections if section in content]
        assert len(sections_found) > 0, (
            f"Expected at least one commit type section in changelog. "
            f"Possible sections: {possible_sections}"
        )

    except FileNotFoundError:
        pytest.skip("git-cliff not installed - install with: pip install git-cliff")
    except subprocess.TimeoutExpired:
        pytest.fail("git-cliff command timed out")


def test_postprocessors_configured(cliff_config: dict):
    """Test that postprocessors are configured for link replacement."""
    changelog = cliff_config["changelog"]

    assert "postprocessors" in changelog, "postprocessors not configured"
    assert len(changelog["postprocessors"]) > 0, "postprocessors list is empty"

    # Check for REPO replacement
    repo_processor = next(
        (p for p in changelog["postprocessors"] if "<REPO>" in p.get("pattern", "")),
        None
    )
    assert repo_processor is not None, "Missing postprocessor for <REPO> placeholder"
    assert "github.com/memyselfmike/gao-agile-dev" in repo_processor["replace"], (
        "REPO replacement should point to GitHub repository"
    )


def test_skip_internal_commits(cliff_config: dict):
    """Test that internal commits (style, test, chore) are configured to be skipped."""
    git = cliff_config["git"]
    commit_parsers = git["commit_parsers"]

    # Commit types that should be skipped
    skip_types = ["style", "test", "chore", "ci", "build"]

    for commit_type in skip_types:
        # Find parsers for this type
        parsers = [
            p for p in commit_parsers
            if "message" in p and commit_type in p["message"].lower()
        ]

        # At least one parser should exist for this type
        if len(parsers) > 0:
            # Check if at least one has skip=true
            has_skip = any(p.get("skip") is True for p in parsers)
            assert has_skip, f"Expected {commit_type} commits to have skip=true"


def test_conventional_commits_format_documented():
    """Test that CONTRIBUTING.md documents conventional commit format."""
    contributing_path = Path(__file__).parent.parent.parent / "CONTRIBUTING.md"

    assert contributing_path.exists(), "CONTRIBUTING.md not found"

    content = contributing_path.read_text(encoding="utf-8")

    # Check for conventional commits documentation
    assert "Conventional Commits" in content, "CONTRIBUTING.md should document Conventional Commits"
    assert "feat" in content, "CONTRIBUTING.md should document 'feat' type"
    assert "fix" in content, "CONTRIBUTING.md should document 'fix' type"
    assert "BREAKING CHANGE" in content or "Breaking Change" in content, (
        "CONTRIBUTING.md should document breaking changes"
    )

    # Check for examples
    assert "```" in content, "CONTRIBUTING.md should have code examples"


def test_beta_versioning_support(cliff_config: dict):
    """Test that configuration supports beta versioning (v0.1.0-beta.1)."""
    git = cliff_config["git"]

    # Tag pattern should allow beta versions
    tag_pattern = git["tag_pattern"]
    assert tag_pattern == "v[0-9].*", (
        "tag_pattern should support beta versions like v0.1.0-beta.1"
    )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
