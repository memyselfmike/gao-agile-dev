"""Tests for git API endpoints (Story 39.25)."""

import pytest
from pathlib import Path
from fastapi.testclient import TestClient
from gao_dev.web.server import create_app
from gao_dev.web.config import WebConfig
from gao_dev.core.git_manager import GitManager


@pytest.fixture
def git_test_project(tmp_path):
    """Create a test project with git repository and commits."""
    project_dir = tmp_path / "test_project"
    project_dir.mkdir()

    # Initialize git repository
    git_manager = GitManager(project_path=project_dir)
    git_manager.init_repo(
        user_name="Test User",
        user_email="test@example.com",
        initial_commit=True,
        create_gitignore=True,
    )

    # Create some test files and commits
    test_file_1 = project_dir / "file1.txt"
    test_file_1.write_text("Line 1\nLine 2\nLine 3\n")
    git_manager.add_all()
    git_manager.commit("feat(test): add file1.txt\n\nFirst feature commit")

    test_file_2 = project_dir / "file2.txt"
    test_file_2.write_text("Content of file 2\n")
    git_manager.add_all()
    git_manager.commit("fix(test): add file2.txt\n\nBug fix commit")

    # Modify file1 to create more changes
    test_file_1.write_text("Line 1\nLine 2\nLine 3\nLine 4\nLine 5\n")
    git_manager.add_all()
    git_manager.commit("refactor(test): update file1.txt\n\nRefactor commit")

    # Agent commit (different email)
    test_file_3 = project_dir / "agent_file.txt"
    test_file_3.write_text("Agent generated file\n")
    git_manager._run_git_command(["config", "user.email", "agent@gao-dev.local"])
    git_manager.add_all()
    git_manager.commit("feat(agent): add agent file\n\nGenerated by agent")

    # Reset email
    git_manager._run_git_command(["config", "user.email", "test@example.com"])

    return project_dir


@pytest.fixture
def test_client(git_test_project):
    """Create test client with git project."""
    # Create .gao-dev directory
    (git_test_project / ".gao-dev").mkdir(exist_ok=True)

    # Create config with frontend dist path
    frontend_dist = git_test_project / "frontend" / "dist"
    frontend_dist.mkdir(parents=True, exist_ok=True)

    config = WebConfig(
        host="127.0.0.1",
        port=3000,
        auto_open=False,
        frontend_dist_path=str(frontend_dist),
    )

    app = create_app(config)
    app.state.project_root = git_test_project

    return TestClient(app)


class TestGitCommitsEndpoint:
    """Tests for /api/git/commits endpoint."""

    def test_get_commits_success(self, test_client):
        """Test successful retrieval of commit list."""
        response = test_client.get("/api/git/commits")

        assert response.status_code == 200
        data = response.json()

        # Verify response structure (Story 39.27 - enhanced response)
        assert "commits" in data
        assert "total" in data
        assert "total_unfiltered" in data
        assert "has_more" in data
        assert "filters_applied" in data

        # Verify we have commits (initial + 3 test commits = 4 total)
        assert len(data["commits"]) >= 4
        assert data["total"] >= 4

        # Verify commit structure
        first_commit = data["commits"][0]
        assert "hash" in first_commit
        assert "short_hash" in first_commit
        assert "message" in first_commit
        assert "author" in first_commit
        assert "timestamp" in first_commit
        assert "files_changed" in first_commit
        assert "insertions" in first_commit
        assert "deletions" in first_commit

        # Verify author structure
        author = first_commit["author"]
        assert "name" in author
        assert "email" in author
        assert "is_agent" in author

    def test_get_commits_pagination(self, test_client):
        """Test pagination with limit and offset."""
        # Get first 2 commits
        response1 = test_client.get("/api/git/commits?limit=2&offset=0")
        assert response1.status_code == 200
        data1 = response1.json()
        assert len(data1["commits"]) <= 2

        # Get next 2 commits
        response2 = test_client.get("/api/git/commits?limit=2&offset=2")
        assert response2.status_code == 200
        data2 = response2.json()

        # Verify different commits
        if len(data1["commits"]) > 0 and len(data2["commits"]) > 0:
            assert data1["commits"][0]["hash"] != data2["commits"][0]["hash"]

    def test_get_commits_author_filter(self, test_client):
        """Test filtering by author."""
        # Filter by user commits
        response = test_client.get("/api/git/commits?author=test@example.com")
        assert response.status_code == 200
        data = response.json()

        # All commits should be from test user
        for commit in data["commits"]:
            assert commit["author"]["email"] == "test@example.com"
            assert commit["author"]["is_agent"] is False

    def test_get_commits_agent_detection(self, test_client):
        """Test agent commit detection."""
        # Get all commits
        response = test_client.get("/api/git/commits?limit=50")
        assert response.status_code == 200
        data = response.json()

        # Find agent commit
        agent_commits = [c for c in data["commits"] if c["author"]["is_agent"]]
        assert len(agent_commits) >= 1

        # Verify agent commit has correct email
        agent_commit = agent_commits[0]
        assert "@gao-dev.local" in agent_commit["author"]["email"]

    def test_get_commits_reverse_chronological(self, test_client):
        """Test commits are returned in reverse chronological order (newest first)."""
        response = test_client.get("/api/git/commits?limit=50")
        assert response.status_code == 200
        data = response.json()

        # Verify order (newest first)
        if len(data["commits"]) >= 2:
            from datetime import datetime

            first_time = datetime.fromisoformat(
                data["commits"][0]["timestamp"].replace("Z", "+00:00")
            )
            second_time = datetime.fromisoformat(
                data["commits"][1]["timestamp"].replace("Z", "+00:00")
            )
            assert first_time >= second_time

    def test_get_commits_empty_repo(self, tmp_path):
        """Test endpoint with empty repository (no commits)."""
        # Create empty git repo
        empty_project = tmp_path / "empty_project"
        empty_project.mkdir()
        (empty_project / ".gao-dev").mkdir()

        git_manager = GitManager(project_path=empty_project)
        git_manager.git_init()

        # Create test client
        frontend_dist = empty_project / "frontend" / "dist"
        frontend_dist.mkdir(parents=True, exist_ok=True)

        config = WebConfig(
            host="127.0.0.1",
            port=3000,
            auto_open=False,
            frontend_dist_path=str(frontend_dist),
        )

        app = create_app(config)
        app.state.project_root = empty_project

        client = TestClient(app)

        # Request commits
        response = client.get("/api/git/commits")
        assert response.status_code == 200
        data = response.json()

        # Should return empty list
        assert len(data["commits"]) == 0
        assert data["total"] == 0
        assert data["has_more"] is False

    def test_get_commits_not_git_repo(self, tmp_path):
        """Test endpoint with non-git directory."""
        # Create non-git directory
        non_git_project = tmp_path / "non_git_project"
        non_git_project.mkdir()
        (non_git_project / ".gao-dev").mkdir()

        # Create test client
        frontend_dist = non_git_project / "frontend" / "dist"
        frontend_dist.mkdir(parents=True, exist_ok=True)

        config = WebConfig(
            host="127.0.0.1",
            port=3000,
            auto_open=False,
            frontend_dist_path=str(frontend_dist),
        )

        app = create_app(config)
        app.state.project_root = non_git_project

        client = TestClient(app)

        # Request commits - should fail
        response = client.get("/api/git/commits")
        assert response.status_code == 404
        assert "Not a git repository" in response.json()["detail"]

    def test_get_commits_limit_bounds(self, test_client):
        """Test limit parameter bounds (1-100)."""
        # Valid limit
        response = test_client.get("/api/git/commits?limit=10")
        assert response.status_code == 200

        # Limit too low (should use minimum)
        response = test_client.get("/api/git/commits?limit=0")
        assert response.status_code == 422  # Validation error

        # Limit too high (should use maximum)
        response = test_client.get("/api/git/commits?limit=101")
        assert response.status_code == 422  # Validation error

    def test_get_commits_file_statistics(self, test_client):
        """Test file statistics are included in commits."""
        response = test_client.get("/api/git/commits?limit=50")
        assert response.status_code == 200
        data = response.json()

        # Find a commit with file changes
        commits_with_changes = [c for c in data["commits"] if c["files_changed"] > 0]

        assert len(commits_with_changes) > 0

        # Verify statistics
        commit = commits_with_changes[0]
        assert commit["files_changed"] >= 1
        assert commit["insertions"] >= 0
        assert commit["deletions"] >= 0

    def test_get_commits_search_filter(self, test_client):
        """Test search filter for commit messages (Story 39.27)."""
        # Search for "fix" in commit messages
        response = test_client.get("/api/git/commits?search=fix")
        assert response.status_code == 200
        data = response.json()

        # All returned commits should have "fix" in message
        for commit in data["commits"]:
            assert "fix" in commit["message"].lower()

        # Verify filter was applied in response
        assert data["filters_applied"]["search"] == "fix"

    def test_get_commits_author_agents_filter(self, test_client):
        """Test filtering by all agents (Story 39.27)."""
        # Filter for agent commits only
        response = test_client.get("/api/git/commits?author=agents")
        assert response.status_code == 200
        data = response.json()

        # All returned commits should be from agents
        for commit in data["commits"]:
            assert commit["author"]["is_agent"] is True

        # Verify filter was applied
        assert data["filters_applied"]["author"] == "agents"

    def test_get_commits_author_user_filter(self, test_client):
        """Test filtering by user commits only (Story 39.27)."""
        # Filter for user commits only
        response = test_client.get("/api/git/commits?author=user&limit=50")
        assert response.status_code == 200
        data = response.json()

        # If there are commits returned, they should all be from users (not agents)
        # Note: If all commits are from agents, result may be empty
        if len(data["commits"]) > 0:
            for commit in data["commits"]:
                assert commit["author"]["is_agent"] is False

        # Verify filter was applied
        assert data["filters_applied"]["author"] == "user"

    def test_get_commits_date_range_filter(self, test_client):
        """Test filtering by date range (Story 39.27)."""
        from datetime import datetime, timedelta, timezone
        from urllib.parse import quote

        # Filter commits from last 7 days (use UTC timezone-aware datetime)
        since_datetime = datetime.now(timezone.utc) - timedelta(days=7)
        since_date = since_datetime.isoformat()

        # URL encode the date to handle + and : characters
        encoded_since = quote(since_date)

        response = test_client.get(f"/api/git/commits?since={encoded_since}")

        # Debug print if response is not 200
        if response.status_code != 200:
            print(f"Response status: {response.status_code}")
            print(f"Response body: {response.json()}")

        assert response.status_code == 200
        data = response.json()

        # Verify all commits are within date range
        for commit in data["commits"]:
            commit_date = datetime.fromisoformat(commit["timestamp"].replace("Z", "+00:00"))
            assert commit_date >= since_datetime

        # Verify filter was applied (allowing for URL decoding differences)
        assert data["filters_applied"]["since"] is not None

    def test_get_commits_multiple_filters(self, test_client):
        """Test combining multiple filters (Story 39.27)."""
        from datetime import datetime, timedelta, timezone
        from urllib.parse import quote

        # Combine: author filter + search
        since_date = (datetime.now(timezone.utc) - timedelta(days=30)).isoformat()
        encoded_since = quote(since_date)

        response = test_client.get(
            f"/api/git/commits?author=user&since={encoded_since}&search=test"
        )
        assert response.status_code == 200
        data = response.json()

        # Verify all filters applied (if there are results)
        for commit in data["commits"]:
            assert commit["author"]["is_agent"] is False  # User filter
            assert "test" in commit["message"].lower()  # Search filter

        # Verify filters_applied object
        assert data["filters_applied"]["author"] == "user"
        assert data["filters_applied"]["since"] is not None
        assert data["filters_applied"]["search"] == "test"

    def test_get_commits_invalid_date_range(self, test_client):
        """Test validation for invalid date range (Story 39.27)."""
        # Start date after end date
        response = test_client.get("/api/git/commits?since=2025-02-01&until=2025-01-01")

        assert response.status_code == 400
        assert "Start date must be before end date" in response.json()["detail"]

    def test_get_commits_total_counts(self, test_client):
        """Test total and total_unfiltered counts (Story 39.27)."""
        # Get all commits
        response_all = test_client.get("/api/git/commits")
        data_all = response_all.json()
        total_unfiltered = data_all["total_unfiltered"]

        # Get filtered commits
        response_filtered = test_client.get("/api/git/commits?search=fix")
        data_filtered = response_filtered.json()

        # Total should be less than or equal to total_unfiltered
        assert data_filtered["total"] <= data_filtered["total_unfiltered"]
        assert data_filtered["total_unfiltered"] == total_unfiltered


class TestGitCommitDiffEndpoint:
    """Tests for /api/git/commits/{hash}/diff endpoint (Story 39.26)."""

    def test_get_commit_diff_success(self, test_client, git_test_project):
        """Test successful retrieval of commit diff."""
        # Get commits to find a hash
        commits_response = test_client.get("/api/git/commits?limit=10")
        commits_data = commits_response.json()
        commit_hash = commits_data["commits"][0]["hash"]

        # Get diff for commit
        response = test_client.get(f"/api/git/commits/{commit_hash}/diff")

        assert response.status_code == 200
        data = response.json()

        # Verify response structure
        assert "files" in data
        assert isinstance(data["files"], list)

        # If there are files, verify structure
        if len(data["files"]) > 0:
            file_change = data["files"][0]
            assert "path" in file_change
            assert "change_type" in file_change
            assert file_change["change_type"] in ["added", "modified", "deleted"]
            assert "insertions" in file_change
            assert "deletions" in file_change
            assert "is_binary" in file_change
            assert "diff" in file_change
            assert "original_content" in file_change
            assert "modified_content" in file_change

    def test_get_commit_diff_added_file(self, test_client, git_test_project):
        """Test diff for commit that adds a new file."""
        # Get commits
        commits_response = test_client.get("/api/git/commits?limit=50")
        commits_data = commits_response.json()

        # Find commit with "add file1.txt" message
        target_commit = next(
            (c for c in commits_data["commits"] if "add file1.txt" in c["message"]), None
        )

        if target_commit:
            response = test_client.get(f"/api/git/commits/{target_commit['hash']}/diff")
            assert response.status_code == 200
            data = response.json()

            # Find file1.txt in changes
            file1_change = next((f for f in data["files"] if "file1.txt" in f["path"]), None)

            if file1_change:
                assert file1_change["change_type"] == "added"
                assert file1_change["insertions"] > 0
                assert file1_change["deletions"] == 0
                assert file1_change["is_binary"] is False
                assert file1_change["original_content"] == ""
                assert "Line 1" in file1_change["modified_content"]

    def test_get_commit_diff_modified_file(self, test_client, git_test_project):
        """Test diff for commit that modifies a file."""
        # Get commits
        commits_response = test_client.get("/api/git/commits?limit=50")
        commits_data = commits_response.json()

        # Find commit with "update file1.txt" message
        target_commit = next(
            (c for c in commits_data["commits"] if "update file1.txt" in c["message"]), None
        )

        if target_commit:
            response = test_client.get(f"/api/git/commits/{target_commit['hash']}/diff")
            assert response.status_code == 200
            data = response.json()

            # Find file1.txt in changes
            file1_change = next((f for f in data["files"] if "file1.txt" in f["path"]), None)

            if file1_change:
                assert file1_change["change_type"] == "modified"
                assert file1_change["insertions"] > 0
                assert file1_change["is_binary"] is False
                assert file1_change["original_content"] != ""
                assert file1_change["modified_content"] != ""
                assert file1_change["original_content"] != file1_change["modified_content"]

    def test_get_commit_diff_short_hash(self, test_client, git_test_project):
        """Test diff endpoint works with short commit hash."""
        # Get commits
        commits_response = test_client.get("/api/git/commits?limit=10")
        commits_data = commits_response.json()
        short_hash = commits_data["commits"][0]["short_hash"]

        # Get diff with short hash
        response = test_client.get(f"/api/git/commits/{short_hash}/diff")

        assert response.status_code == 200
        data = response.json()
        assert "files" in data

    def test_get_commit_diff_invalid_hash(self, test_client):
        """Test diff endpoint with invalid commit hash."""
        response = test_client.get("/api/git/commits/invalidhash123/diff")

        assert response.status_code == 404
        assert "Commit not found" in response.json()["detail"]

    def test_get_commit_diff_not_git_repo(self, tmp_path):
        """Test diff endpoint with non-git directory."""
        # Create non-git directory
        non_git_project = tmp_path / "non_git_project"
        non_git_project.mkdir()
        (non_git_project / ".gao-dev").mkdir()

        # Create test client
        frontend_dist = non_git_project / "frontend" / "dist"
        frontend_dist.mkdir(parents=True, exist_ok=True)

        config = WebConfig(
            host="127.0.0.1",
            port=3000,
            auto_open=False,
            frontend_dist_path=str(frontend_dist),
        )

        app = create_app(config)
        app.state.project_root = non_git_project

        client = TestClient(app)

        # Request diff - should fail
        response = client.get("/api/git/commits/abc123/diff")
        assert response.status_code == 404
        assert "Not a git repository" in response.json()["detail"]

    def test_get_commit_diff_binary_detection(self, test_client, git_test_project):
        """Test binary file detection in diff (would need actual binary file)."""
        # Note: This test would require creating a commit with a binary file
        # For now, we just verify the structure supports is_binary flag
        commits_response = test_client.get("/api/git/commits?limit=10")
        commits_data = commits_response.json()
        commit_hash = commits_data["commits"][0]["hash"]

        response = test_client.get(f"/api/git/commits/{commit_hash}/diff")
        assert response.status_code == 200
        data = response.json()

        # Verify all files have is_binary field
        for file_change in data["files"]:
            assert "is_binary" in file_change
            assert isinstance(file_change["is_binary"], bool)

            # If binary, content fields should be null
            if file_change["is_binary"]:
                assert file_change["diff"] is None
                assert file_change["original_content"] is None
                assert file_change["modified_content"] is None
